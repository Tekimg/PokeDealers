import requests

from transbank.common.headers_builder import HeadersBuilder
from transbank.common.integration_type import IntegrationType, webpay_host
from transbank.common.options import Options, WebpayOptions
from transbank import patpass_by_webpay
from transbank.error.transaction_create_error import TransactionCreateError
from transbank.patpass_by_webpay.request import TransactionCreateRequest
from transbank.patpass_by_webpay.schema import TransactionCreateRequestSchema, TransactionCreateResponseSchema
from transbank.patpass_by_webpay.response import TransactionCreateResponse
from transbank.webpay.webpay_plus.response import TransactionCommitResponse, TransactionStatusResponse
from transbank.webpay.webpay_plus.transaction import Transaction as T


class Transaction(object):
    @classmethod
    def __base_url(cls, integration_type: IntegrationType) -> str:
        return "{}/rswebpaytransaction/api/webpay/v1.2/transactions".format(
            webpay_host(integration_type))

    @classmethod
    def build_options(cls, options: Options = None) -> Options:
        alt_options = WebpayOptions(patpass_by_webpay.commerce_code, patpass_by_webpay.api_key,
                                    patpass_by_webpay.integration_type)

        if options is not None:
            alt_options.commerce_code = options.commerce_code or patpass_by_webpay.commerce_code
            alt_options.api_key = options.api_key or patpass_by_webpay.api_key
            alt_options.integration_type = options.integration_type or patpass_by_webpay.integration_type

        return alt_options

    @classmethod
    def create(cls, buy_order: str, session_id: str, amount: float, return_url: str, options: Options = None) \
            -> TransactionCreateResponse:
        options = cls.build_options(options)
        endpoint = cls.__base_url(options.integration_type)
        request = TransactionCreateRequest(buy_order, session_id, amount, return_url)

        # Realizar la solicitud POST
        response = requests.post(endpoint, data=TransactionCreateRequestSchema().dumps(request).data, headers=HeadersBuilder.build(options))
        json_response = response.text

        # Verificar si la respuesta es válida antes de continuar
        if response.status_code not in (200, 299):
            print("Error en la respuesta:", json_response)  # Imprimir la respuesta para diagnóstico
            raise TransactionCreateError(message="Invalid response", code=response.status_code)

        # Intentar deserializar la respuesta en un diccionario
        try:
            dict_response = TransactionCreateResponseSchema().loads(json_response).data
            print("Respuesta deserializada:", dict_response)  # Imprimir dict_response para diagnóstico
        except Exception as e:
            print("Error al procesar la respuesta:", e)  # Mostrar el error si no se puede procesar
            print("Respuesta de la API:", json_response)  # Imprimir la respuesta para depuración
            raise TransactionCreateError(message="Error procesando la respuesta", code=response.status_code)

        # Comprobar que dict_response tiene las claves correctas antes de intentar acceder a ellas
        if isinstance(dict_response, dict) and 'url' in dict_response and 'token' in dict_response:
            return TransactionCreateResponse(**dict_response)
        else:
            print("Respuesta inesperada:", dict_response)  # Para diagnóstico
            raise TransactionCreateError(message="Respuesta inesperada de la API", code=response.status_code)

    @classmethod
    def commit(cls, token: str, options: Options = None) -> TransactionCommitResponse:
        return T.commit(token, cls.build_options(options))

    @classmethod
    def status(cls, token: str, options: Options = None) -> TransactionStatusResponse:
        return T.status(token, cls.build_options(options))
